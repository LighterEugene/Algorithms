import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;

//Примеры применения хеш-функций в реальной жизни:
//Проверка целостности данных:
//
//Хеш-функции используются для проверки того, что данные не были изменены.
// Например, при скачивании файлов часто предоставляют хеш (например, MD5 или SHA-256),
// чтобы проверить, что файл загружен правильно и не был изменён.
//Хранение паролей:
//
//В системах безопасности пароли никогда не хранятся в явном виде.
// Вместо этого хеш-функция вычисляет хеш пароля, и он сохраняется.
// При проверке пароля пользователь вводит свой пароль, и система сравнивает хеши.
//Цифровые подписи и аутентификация:
//
//В цифровых подписях хеш-функции используются для создания уникальной подписи документа.
// Подпись создаётся на основе хеша документа и закрытого ключа,
// что позволяет подтвердить подлинность документа и его неизменность.
//Распределение данных в хэш-таблицах:
//
//Хеш-функции применяются в структурах данных, таких как хэш-таблицы или хэш-карты (HashMap).
// Они используют хеширование для быстрого поиска, добавления и удаления элементов.
//Блокчейн и криптовалюты (например, Bitcoin):
//
//В технологии блокчейн каждая транзакция и блок данных хэшируются,
// что гарантирует неизменность информации. Хеш-функции обеспечивают целостность блоков,
// а в Bitcoin они используются в процессе майнинга для создания новых блоков.


public class RSAGeneration {
    public static void main(String[] args) {
        try {
            // Генерация пары ключей RSA
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
            keyGen.initialize(2048); // Устанавливаем размер ключа (2048 бит)
            KeyPair pair = keyGen.generateKeyPair();

            // Получаем публичный ключ
            PublicKey publicKey = pair.getPublic();

            // Печатаем публичный ключ в открытом виде (в кодировке Base64)
            System.out.println("Публичный ключ RSA: " + java.util.Base64.getEncoder().encodeToString(publicKey.getEncoded()));
        } catch (NoSuchAlgorithmException e) {
            System.out.println("Ошибка при генерации ключа: " + e.getMessage());
        }
    }
}
//ровень 2:
//Изучение алгоритмов хеширования и их применения
//MD5 (Message Digest 5):
//
//Описание: MD5 создаёт 128-битное (16-байтное) хеш-значение. Это один из старейших и наиболее широко используемых хеш-алгоритмов.
//Недостатки: MD5 считается небезопасным для криптографических целей,
// так как уязвим к атакам на коллизии (когда разные входные данные дают одинаковый хеш).
//Применение: Используется для проверки целостности файлов, но не для безопасности.
//SHA-1 (Secure Hash Algorithm 1):
//
//Описание: SHA-1 создаёт 160-битное (20-байтное) хеш-значение.
//Недостатки: Как и MD5, уязвим к атакам на коллизии.
// Не рекомендуется для криптографического использования.
//Применение: Ранее широко использовался в цифровых сертификатах и верификации подписей,
// но теперь заменён более надёжными алгоритмами.
//SHA-256:
//
//Описание: SHA-256 является частью семейства алгоритмов SHA-2.
// Он создаёт 256-битное хеш-значение (32 байта).
//Преимущества: Более безопасен, чем MD5 и SHA-1.
// На данный момент считается надёжным и широко используется.
//Применение: Используется в блокчейнах (например, Bitcoin),
// для цифровых подписей, SSL/TLS сертификатов и верификации данных.
//SHA-512:
//
//Описание: SHA-512 — это также часть семейства SHA-2, но создаёт более длинный хеш — 512-битное
// хеш-значение (64 байта).
//Применение: Используется в тех случаях, где требуется ещё более высокий уровень безопасности,
// например, в шифровании данных и верификации крупных файлов.